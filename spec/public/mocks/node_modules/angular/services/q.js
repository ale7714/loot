{
	/**
	 * Implementation
	 */
	class QMockProvider {
		constructor() {
			// Mock $q object
			this.$q = {
				defer() {
					let	isResolved = false,
							promiseValue,
							callbackResult;

					function updateValueAndReturn(result, promise) {
						// If the callback yielded a promise, we'll simply return that
						if (result && result.then && angular.isFunction(result.then)) {
							return result;
						}

						// Otherwise, update the promise value to the callback result; and return the existing promise
						promiseValue = result || promiseValue;

						return promise;
					}

					return {
						resolve(value) {
							promiseValue = value;
							isResolved = true;
						},
						reject(value) {
							promiseValue = value;
						},
						promise: {
							then(successCallback, errorCallback) {
								if (isResolved) {
									callbackResult = successCallback(promiseValue);
								} else if (errorCallback) {
									callbackResult = errorCallback(promiseValue);
								}

								return updateValueAndReturn(callbackResult, this);
							},
							catch(errorCallback) {
								if (!isResolved) {
									callbackResult = errorCallback(promiseValue);
								}

								return updateValueAndReturn(callbackResult, this);
							}
						}
					};
				},
				promisify(success, error) {
					// Helper function to promise-ify a stub with success and error responses

					// Create two new promises, one for a success and one for an error
					const qSuccess = this.defer(),
								qError = this.defer(),
								stub = sinon.stub();

					// Auto-resolve the success promise with the specified success response
					qSuccess.resolve(success && success.response);

					// Auto-reject the error promise with the specified error response
					qError.reject((error && error.response) || {data: "unsuccessful"});

					// Configure the stub to return the appropriate promise based on the call arguments
					if (!success || (angular.isObject(success) && !success.args)) {
						// No success args specified, so default response is a success
						stub.returns(qSuccess.promise);
					} else {
						stub.withArgs(sinon.match(success.args || success)).returns(qSuccess.promise);
					}

					if (error) {
						stub.withArgs(sinon.match((error && error.args) || error)).returns(qError.promise);
					}

					return stub;
				}
			};
		}

		$get() {
			// Return the mock $q object
			return this.$q;
		}
	}

	/**
	 * Registration
	 */
	angular
		.module("ogAngularMocks")
		.provider("$qMock", QMockProvider);

	/**
	 * Dependencies
	 */
	QMockProvider.$inject = [];
}
